package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"text/template"
)

// Config struct 用于解析 JSON 文件结构
type Config struct {
	CertFile   string `json:"cert_file"`
	KeyFile    string `json:"key_file"`
	Username   string `json:"username"`
	Password   string `json:"password"`
	TargetURL  string `json:"target_url"`
	LoginURL   string `json:"login_url"`
	CookieName string `json:"cookie_name"`
	// Automatically Generated
	Salt  string `json:"salt,omitempty"`
	Token string `json:"token,omitempty"`
}

const (
	inputFile  = "config.json"
	outputFile = "config_compiled.go"
)

// tmpl 是用于生成 Go 文件的模板
var tmpl = template.Must(template.New("config").Parse(`
// Code generated by go generate. DO NOT EDIT.

package main

const (
	CertFile   = "{{.CertFile}}"
	KeyFile    = "{{.KeyFile}}"
	Salt       = "{{.Salt}}"
	TargetURL  = "{{.TargetURL}}"
	LoginURL   = "{{.LoginURL}}"
	CookieName = "{{.CookieName}}"
)

var Token = {{.Token}}
`))

func byteSliceToString(b []byte) string {
	result := ""
	for i, v := range b {
		if i > 0 {
			result += ", "
		}
		result += fmt.Sprintf("0x%02x", v)
	}
	return result
}

func computeToken(username string, password string, salt string) string {
	hash := sha256.New()
	hash.Write([]byte(username + ":" + password + ":" + salt))
	return fmt.Sprintf("[]byte{%s}", byteSliceToString(hash.Sum(nil)))
}

func generateSalt(length int) string {
	b := make([]byte, length)
	rand.Read(b)

	saltString := base64.URLEncoding.EncodeToString(b)
	return saltString
}

func main() {
	data, err := os.ReadFile(inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading config file: %v\n", err)
		return
	}

	var cfg Config
	if err := json.Unmarshal(data, &cfg); err != nil {
		fmt.Fprintf(os.Stderr, "Error unmarshalling config: %v\n", err)
		return
	}
	cfg.Salt = generateSalt(12)
	cfg.Token = computeToken(cfg.Username, cfg.Password, cfg.Salt)

	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		return
	}
	defer f.Close()

	if err := tmpl.Execute(f, cfg); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		return
	}

	fmt.Printf("Successfully generated %s from %s\n", outputFile, inputFile)
}
